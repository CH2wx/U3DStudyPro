1、坐标的变换顺序： 缩放 -> 旋转 -> 平移
	在物体刚刚放入世界坐标系的时候使用的是本地坐标，也就是本地和全局坐标系的原点和坐标轴都是重合的（当然两者分别使用了左右手坐标系时除外 - 那是BUG），此时所有物体都“把世界坐标系当做自己的本地坐标系”。
	而经过了坐标变换之后：
		1） 缩放变换不改变坐标轴的走向，也不改变原点的位置，所以两个坐标系仍然重合。
		2） 旋转变换改变坐标轴的走向，但不改变原点的位置，所以两个坐标系坐标轴不再处于相同走向。
		3） 平移变换不改变坐标轴走向，但改变原点位置，两个坐标系原点不再重合。
	颠倒后出现的情况：
		1） 当缩放在旋转之后进行时：和本地坐标轴成角度的缩放（会导致扭曲，像踩扁的可乐罐）。
		2） 当缩放和旋转在平移之后进行时：绕自己几何中心以外位置的原点的旋转 （地球公转式） 和缩放。

2、什么是弧度？
	像度数一样，它们可以用作旋转的量度。 使用单位圆时，弧度与您沿其圆周行进的距离匹配。 由于圆周的长度等于圆半径的2π倍，因此1个弧度等于π/ 180度。
	π是圆的周长与其直径之比。

3、乘法顺序重要吗？
	X乘以 X×（Y×Z）=（X×Y）×Z的顺序无关紧要。 最终得到一个不同的中间步骤，但最终结果却相同。 但是，在此方程式中对矩阵重新排序确实会改变旋转顺序，会产生不同的结果。 因此X×Y×Z≠Z×Y×X 在这方面，矩阵乘法不同于单数乘法。
	Unity的实际轮换顺序为ZXY。

4、什么是包围盒？
	拿到任何一个网格。找出适合该网格的最小的立方体。就是一个包围盒。它是自动从对象的网格中生成出来的。
	Unity通过检查对象的包围盒是否与摄影机的视锥相交来完成验证。

5、为什么编写Shader时需要关键字
	着色器通道可以包含除着色器程序以外的其他语句。因此，程序必须以某种方式分开。
	那为什么不使用另一个块呢？
	不知道。你后面还会遇到更多这样的奇怪情况。它们通常是曾经一些已经过时的设计决策。由于需要向后兼容，所以，我们仍然需要使用它们。

6、pragma是啥？
    pragma这个词来自希腊语，指的是一项行动或需要完成的事情。许多编程语言都使用它来发出特殊的编译器指令。

7、Unity的UnityCG.cginc库
    UnityShaderVariables.cginc 定义了渲染所需的一堆着色器变量，例如变换，相机和光照数据。这些都在需要时由Unity设置。
    HLSLSupport.cginc 进行了设置，因此无论代码针对的是哪个平台，都可以使用相同的代码进行编写。无需担心使用特定于平台的数据类型等。
    UnityInstancing.cginc 专门用于实例化支持，这是一种减少绘制调用的特定渲染技术。尽管它不直接包含文件，但依赖于UnityShaderVariables。
    请注意，这些文件的内容将有效地复制到你自己的文件中，从而替换了include指令。这发生在执行所有预处理指令的预处理步骤中。这些指令都是以#开头的所有语句，例如#include和#pragma。完成该步骤后，再次处理代码，并对其进行实际编译。
    如果多次包含同一个文件会发生什么？
        它的内容会多次复制到你的代码中。通常，你不想这样做，因为重复的定义很可能会导致编译器错误。

8、0这个返回值有效值吗？
    当使用这样的单个值时，编译器将对所有float组件重复该值。你也可以是显式的，并根据需要返回float4（0，0，0，0）。

9、alpha为0不会完全透明吗？
    除非我们的着色器实际上忽略了Alpha通道，不然肯定会。因为我们正在使用不透明的着色器。但如果我们编写的是支持透明度的着色器，这个结果就会是透明的。

10、可以省略位置参数吗？
    如果不使用，最好将其省略。但是，当涉及多个参数时，这会使某些着色器编译器感到困惑。因此，最好将片段程序输入与顶点程序输出完全匹配起来。

11、什么是uniform 变量？
    uniform表示变量对网格的所有顶点和片段具有相同的值。因此，它在所有顶点和片段上都是统一的。

12、_ST是什么意思？
    _ST后缀代表“缩放”和“平移”或类似名称。为什么不使用_TO来指代平铺和偏移？因为Unity一直使用_ST，并且向后兼容要求它保持这种方式，哪怕术语可能已更改了。

13、什么是宏？
    UnityCG.cginc包含一个方便的宏，可为我们简化此样板。我们可以将其用作方便的速记。
    宏类似于一个函数，在预处理代码阶段之前对其进行展开，然后对展开后的代码进行编译。这允许对代码进行文本操作，例如将_ST附加到变量名。TRANSFORM_TEX宏使用此技巧。如果你好奇的话，可以看看它的定义。

14、细节纹理必须是灰度的吗？
    它们不必是灰度的，但通常是灰度的。灰度细节纹理将通过变暗和变亮来严格调整原始颜色。这是相对直接的方式。与非灰色的颜色相乘会产生较不直观的结果。彩色细节纹理用于产生细微的颜色偏移。

15、什么是伽玛空间？
    伽玛空间是指经过伽玛校正的颜色。伽玛校正是对光强度的调整。最简单的方法是将原始值提高到一定的幂，即value gamma。伽马值为1表示没有变化。伽马值为2表示原始值是平方的。

16、为什么混合区域在线性颜色空间中看起来不同？
    我们的splat贴图会绕过sRGB采样，因此混合不应该取决于我们使用的颜色空间，对吗？图示贴图确实不受影响。但是混合发生的色彩空间确实发生了变化。
    对于伽玛空间渲染，样本将在伽玛空间中混合，仅此而已。但是，当在线性空间中进行渲染时，它们首先会转换为线性空间，然后进行混合，然后再转换回伽玛空间。结果略有不同。在线性空间中，混合也是线性的。但是在伽玛空间中，混合会偏向深色。

17、整个电磁频谱是多少？
	我们可以看到东西，因为我们的眼睛可以检测到电磁辐射。单个光量子称为光子。我们可以看到一部分电磁波谱，它们被称为可见光。其余的频谱对我们来说是看不见的。
	频谱分为频谱带。从低频到高频，这些被称为无线电波，微波，红外线，可见光，紫外线，X射线和伽马射线。
	光源发光。其中一些光线会撞击物体。一些光线会从物体上反射出来。如果那束光最终射到我们的眼睛或相机镜头上，那么我们就可以看到物体了。

18、反转比例尺，但旋转角度应保持不变。应该怎么做？
	我们将对象的变换矩阵描述为O = T1T2T3 ...但我们可以比这更具体。我们知道层次结构中的每个步骤都结合了缩放，旋转和定位。因此，每个T 都可以分解为SRP。
	这意味着 O = S1R1P1S2R2P2S3R3P3 ...我们用O = S1R1P1S2R2P2替代，以便简短描述。
	因为法线是方向向量，所以我们不用在乎它的重新定位。这样的话，我们可以将其进一步缩短为O = S1R1S2R2，我们只需要考虑3 x 3矩阵。
	我们想反转缩放比例，但保持旋转不变。因此，需要一个新的矩阵：
		O = S1^-1 R1 S2^-1 R2

	逆矩阵如何工作？
		矩阵的逆矩阵用 M-1表示。它也是一个矩阵，当它与某个矩阵相乘时，将撤消该矩阵和另一个矩阵的运算结果。彼此相反。

19、Unity的着色器不对观测方向插值吗？
	会差值。Unity的着色器在顶点程序中计算视觉方向并对其进行插值。归一化是在片段程序中完成的，或者在功能不强的硬件的顶点程序中完成的。两种方法都可以。

20、反射向量如何工作？
	你可以通过D-2N(N·D)的公式，用法线N计算出方向D




